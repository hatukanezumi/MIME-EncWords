NAME
    MIME::EncWords - deal with RFC 2047 encoded words (improved)

SYNOPSIS
    *MIME::EncWords is aimed to be another implimentation of MIME::Words so
    that it will achive more exact conformance with RFC 2047 (former RFC
    1522) specifications. Additionally, it contains some improvements.
    Following synopsis and descriptions are inherited from its inspirer,
    then added descriptions on improvements or changes and clarifications.*

    Before reading further, you should see MIME::Tools to make sure that you
    understand where this module fits into the grand scheme of things. Go
    on, do it now. I'll wait.

    Ready? Ok...

        use MIME::EncWords qw(:all);

        ### Decode the string into another string, forgetting the charsets:
        $decoded = decode_mimewords(
              'To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>',
              );

        ### Split string into array of decoded [DATA,CHARSET] pairs:
        @decoded = decode_mimewords(
              'To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>',
              );

        ### Encode a single unsafe word:
        $encoded = encode_mimeword("\xABFran\xE7ois\xBB");

        ### Encode a string, trying to find the unsafe words inside it:
        $encoded = encode_mimewords("Me and \xABFran\xE7ois\xBB in town");

DESCRIPTION
    Fellow Americans, you probably won't know what the hell this module is
    for. Europeans, Russians, et al, you probably do. ":-)".

    For example, here's a valid MIME header you might get:

          From: =?US-ASCII?Q?Keith_Moore?= <moore@cs.utk.edu>
          To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>
          CC: =?ISO-8859-1?Q?Andr=E9_?= Pirard <PIRARD@vm1.ulg.ac.be>
          Subject: =?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
           =?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?=
           =?US-ASCII?Q?.._cool!?=

    The fields basically decode to (sorry, I can only approximate the Latin
    characters with 7 bit sequences /o and 'e):

          From: Keith Moore <moore@cs.utk.edu>
          To: Keld J/orn Simonsen <keld@dkuug.dk>
          CC: Andr'e  Pirard <PIRARD@vm1.ulg.ac.be>
          Subject: If you can read this you understand the example... cool!

    Supplement: Fellow Americans, Europeans, you probably won't know what
    the hell this module is for. East Asians, et al, you probably do. ":-)".

    For example, here's a valid MIME header you might get:

          Subject: =?EUC-KR?B?sNTAuLinKGxhemluZXNzKSwgwvzB9ri7seIoaW1w?=
           =?EUC-KR?B?YXRpZW5jZSksILGzuLgoaHVicmlzKQ==?=

    The fields basically decode to (sorry, I cannot approximate the
    non-Latin multibyte characters with any 7 bit sequences):

          Subject: ???(laziness), ????(impatience), ??(hubris)

PUBLIC INTERFACE
    decode_mimewords ENCODED, [OPTS...]
        *Function.* Go through the string looking for RFC-1522-style "Q"
        (quoted-printable, sort of) or "B" (base64) encoding, and decode
        them.

        In an array context, splits the ENCODED string into a list of
        decoded "[DATA, CHARSET]" pairs, and returns that list. Unencoded
        data are returned in a 1-element array "[DATA]", giving an effective
        CHARSET of "undef".

            $enc = '=?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>';
            foreach (decode_mimewords($enc)) {
                print "", ($_[1] || 'US-ASCII'), ": ", $_[0], "\n";
            }

        In a scalar context, joins the "data" elements of the above list
        together, and returns that. *Warning: this is information-lossy,*
        and probably *not* what you want, but if you know that all charsets
        in the ENCODED string are identical, it might be useful to you.
        (Before you use this, please see "unmime" in MIME::WordDecoder,
        which is probably what you want.) Note: See also "Charset" option
        below.

        In the event of a syntax error, $@ will be set to a description of
        the error, but parsing will continue as best as possible (so as to
        get *something* back when decoding headers). $@ will be false if no
        error was detected.

        Any arguments past the ENCODED string are taken to define a hash of
        options:

        Charset
            Improvement by this module: Name of character set by which data
            elements in scalar context will be converted. If this option is
            specified as special value "_UNICODE_", returned value will be
            Unicode string.

            When Unicode/multibyte support is disabled (see "USE_ENCODE" in
            MIME::Charset), this option will not have any effects.

            Note: This feature is still information-lossy, *except* when
            "_UNICODE_" is specified.

        Detect7bit
            Improvement by this module: Try to detect 7-bit charset on
            unencoded portions. Default is "YES". When Unicode/multibyte
            support is disabled, this option will not have any effects (see
            "USE_ENCODE" in MIME::Charset). Note: This feature was
            introduced at release 1.000.

        Field
            Name of the mail field this string came from. *Currently
            ignored.*

        Improvement by this module: Adjacent encoded-words with same charset
        will be concatenated to handle multibyte sequences safely.

        Change by this module: Malformed base64 encoded-words will be kept
        encoded. In this case $@ will be set.

        Compatibility with MIME::Words: Whitespaces surrounding unencoded
        data will not be stripped.

    encode_mimeword RAW, [ENCODING], [CHARSET]
        *Function.* Encode a single RAW "word" that has unsafe characters.
        The "word" will be encoded in its entirety.

            ### Encode "<<Franc,ois>>":
            $encoded = encode_mimeword("\xABFran\xE7ois\xBB");

        You may specify the ENCODING ("Q" or "B"), which defaults to "Q".
        Improvement by this module: You may also specify it as ``special''
        value: "S" to choose shorter one of either "Q" or "B".

        You may specify the CHARSET, which defaults to "iso-8859-1".

        Change by this module: Spaces will be escaped with ``_'' by "Q"
        encoding.

    encode_mimewords RAW, [OPTS]
        *Function.* Given a RAW string, try to find and encode all "unsafe"
        sequences of characters:

            ### Encode a string with some unsafe "words":
            $encoded = encode_mimewords("Me and \xABFran\xE7ois\xBB");

        Returns the encoded string.

        Improvement by this module: RAW may be a Unicode string when
        Unicode/multibyte support is enabled (see "USE_ENCODE" in
        MIME::Charset). Furthermore, RAW may be a reference to that returned
        by "decode_mimewords" on array context. In latter case "Charset"
        option (see below) will be overridden (see also notes below).

        Any arguments past the RAW string are taken to define a hash of
        options:

        Charset
            Encode all unsafe stuff with this charset. Default is
            'ISO-8859-1', a.k.a. "Latin-1".

        Detect7bit
            Improvement by this module: When "Encoding" option (see below)
            is specified as "a" and "Charset" option is unknown, try to
            detect 7-bit charset on given RAW string. Default is "YES". When
            Unicode/multibyte support is disabled, this option will not have
            any effects (see "USE_ENCODE" in MIME::Charset).

        Encoding
            The encoding to use, "q" or "b". The default is "q". Improvement
            by this module: You may also specify ``special'' values: "a"
            will automatically choose recommended encoding to use (with
            charset conversion if alternative charset is recommended: see
            MIME::Charset); "s" will choose shorter one of either "q" or
            "b".

        Field
            Name of the mail field this string will be used in. Improvement
            by this module: Length of mail field name will be considered in
            the first line of encoded header.

        Minimal
            Improvement by this module: Takes care of natural word
            separators (i.e. whitespaces) in the text to be encoded. If "NO"
            is specified, this module will encode whole text (if encoding
            needed) not regarding whitespaces; encoded-words exceeding line
            length will be splitted based only on their lengths. Default is
            "YES".

            Note: As of release 0.040, default has been changed to "YES" to
            ensure compatibility with MIME::Words. On earlier releases, this
            option was fixed to be "NO".

        Replacement
            Improvement by this module: See "ERROR HANDLING" in
            MIME::Charset. Note: This feature was introduced at release
            1.000.

        Notes on improvement by this module: When RAW is an arrayref,
        adjacent encoded-words are concatenated. Then they are splitted
        taking care of character boundaries of multibyte sequences, when
        Unicode/multibyte support is enabled. Portions for unencoded data
        should include surrounding whitespace(s), or they will be merged
        into adjoining encoded word(s).

VERSION
    Consult $VERSION variable.

    Development versions of this module may be found at
    <http://hatuka.nezumi.nu/repos/MIME-EncWords/>.

SEE ALSO
    MIME::Charset, MIME::Tools

AUTHORS
    The original version of function decode_mimewords() is derived from
    MIME::Words module that was written by: Eryq (eryq@zeegee.com), ZeeGee
    Software Inc (http://www.zeegee.com). David F. Skoll
    (dfs@roaringpenguin.com) http://www.roaringpenguin.com

    Other stuff are rewritten or added by: Hatuka*nezumi - IKEDA Soji
    <hatuka(at)nezumi.nu>.

    All rights reserved. This program is free software; you can redistribute
    it and/or modify it under the same terms as Perl itself.

